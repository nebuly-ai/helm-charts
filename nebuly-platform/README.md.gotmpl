# Nebuly Platform

{{ template "chart.deprecationWarning" . }}

{{ template "chart.badgesSection" . }}

{{ template "chart.description" . }}

{{ template "chart.homepageLine" . }}

{{ template "chart.requirementsSection" . }}


## Prerequisites

### Databases

The platform requires a PostgreSQL Server configured with the databases listed in the table below.
The databases can be created with arbitrary names, as the name of each database
can be provided as a configuration parameter during the installation process of the platform.

| Database        | Helm Value                        | Collation  | Charset | Description                                                                          |
|-----------------|-----------------------------------|------------|---------|--------------------------------------------------------------------------------------|
| Backend         | `backend.postgresDatabase.name`        | en_US.utf8 | utf8    | It stores users information such as settings, dashboards and projects.               |
| Auth Service    | `authService.postgresDatabase.name` | en_US.utf8 | utf8    | It stores the identity of the users and the respective permissions. |
| Analytic        | `analyticDatabase.name`           | en_US.utf8 | utf8    | It stores analytic data such as user LLM interactions                                |

The PostgreSQL server must meet the following requirements:

* The minimum supported version of PostgreSQL is 14.0.
* The server must support password authentication

### Apache Kafka

The Platform requires an [Apache Kafka](https://kafka.apache.org/) server for storing the
ingested events waiting to be processed.

At moment, the Platform only supports
[SASL/PLAIN](https://docs.confluent.io/platform/current/kafka/authentication_sasl/authentication_sasl_plain.html#kafka-sasl-auth-plain)
authentication with username and password, so the Kafka server must be configured to use this authentication method.

The Platform uses several topics in the Kafka server. You can customize the names of the topics through the following
values:

* `kafka.topicEventsMain`
* `kafka.topicEventsRetry1`
* `kafka.topicEventsRetry2`
* `kafka.topicEventsRetry3`
* `kafka.topicEventsDlq`

If the topics do not exist, the Platform creates them automatically at startup. It is recommended to create the topics
manually with the desired configuration before installing the Platform, so that its possible to
configure each topic with the desired number of partitions and replication factor according to the expected load.

## Installation

### 1. Create a GitHub personal access token

You first need to create a GitHub personal access token with the `read:packages` scope to pull the required Docker
images. You can refer to
the [GitHub documentation](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).

### 2. Create a container image pull secret

You need to create a container image pull secret with the PAT token you created in the previous step. You can
do that following the steps below.

1. Create a base64 encoded string of the token value with the following command, where `<username>` is your GitHub
username and `<token>` is the value of the PAT token you created in the previous step.

```bash
echo -n "<username>:<token>" | base64
```

2. Create a JSON file containing the base64 representation of your PAT. You can do that with the following commands,
   replacing the placeholder `<your-base64-token>` with the value you obtained in the previous step:

```bash
cat <<EOT > secret.json
{
  "auths": {
    "ghcr.io": {
      "auth": "<your-base64-token>"
    }
  }
}
EOT
```

3. Create the image pull secret
```bash
kubectl create secret docker-registry nebuly-docker-pull --from-file=.dockerconfigjson=secret.json --namespace nebuly
```

4. Include the created secret in the `imagePullSecrets` field of the `values.yaml` file.

```yaml
imagePullSecrets:
  - name: nebuly-docker-pull
```

### 3. Install the chart
You can install the chart in the namespace `nebuly` with the following command:

```bash
helm install oci://ghcr.io/nebuly-ai/helm-charts/nebuly-platform \
  --version 0.1.0 \
  --namespace nebuly \
  --generate-name \
  --create-namespace \
  -f values.yaml
```

## Exposing the services to the Internet

To expose the Platform services to the Internet, you need to specify the Ingress configurations of each
service in the `values.yaml` file. You can expose the following services:

* `frontend`: the Platform frontend application
* `authService`: endpoints used for authentication and authorization
* `backend`: the Platform backend APIs used by the frontend
* `eventIngestion`: the Platform event ingestion APIs, used for receiving events and interactions.

Below you can find an example configuration for exposing all the services using
[ingress-nginx](https://github.com/kubernetes/ingress-nginx) as ingress
controller and [cert-manager](https://github.com/cert-manager/cert-manager) for managing SSL certificates.

The configuration below exposes the services using the following domains:
* `platform.example.nebuly.com`: the frontend application
* `backend.example.nebuly.com`: the backend APIs
* `backend.example.nebuly.com/auth`: the authentication and authorization endpoints
* `backend.example.nebuly.com/event-ingestion`: the event ingestion APIs


<details>
<summary> <b> Example values for ingress configuration </b> </summary>

```yaml
backend:
  ingress:
    enabled: true
    className: nginx
    annotations:
        cert-manager.io/cluster-issuer: letsencrypt
    tls:
      - hosts:
          - backend.example.nebuly.com
        secretName: tls-secret-backend
    hosts:
      - host: backend.example.nebuly.com
        paths:
          - path: /api
            pathType: Prefix

frontend:
  backendApiUrl: https://backend.example.nebuly.com
  rootUrl: https://platform.example.nebuly.com
  authApiUrl: https://backend.example.nebuly.com/auth

  ingress:
    enabled: true
    className: nginx
    annotations:
        cert-manager.io/cluster-issuer: letsencrypt
    tls:
      - hosts:
          - platform.example.nebuly.com
        secretName: tls-secret-frontend
    hosts:
      - host: platform.example.nebuly.com
        paths:
          - path: /
            pathType: Prefix

eventIngestion:
  ingress:
    enabled: true
    className: nginx
    annotations:
        nginx.ingress.kubernetes.io/use-regex: "true"
        nginx.ingress.kubernetes.io/rewrite-target: $1
        cert-manager.io/cluster-issuer: letsencrypt
    tls:
      - hosts:
          - backend.example.nebuly.com
        secretName: tls-secret-backend
    hosts:
      - host: backend.example.nebuly.com
        paths:
          - path: /event-ingestion(/|$)(.*)
            pathType: Prefix

authService:
  ingress:
    enabled: true
    className: nginx
    annotations:
        cert-manager.io/cluster-issuer: letsencrypt
    tls:
      - hosts:
          - backend.example.nebuly.com
        secretName: tls-secret-backend
    hosts:
      - host: backend.example.nebuly.com
        paths:
          - path: /auth
            pathType: Prefix
```
</details>


## Examples

### Microsoft Azure installation

The following is an example of `values.yaml` for installing the Platform on Microsoft Azure.

The Platform will use the following Azure services:

* Azure OpenAI: used for processing the ingested data (text embeddings, text generation)
* Azure Machine Learning: used for storing the ingested data (frustration and warnings detection)
* Azure Key Vault: used for storing API Keys
* Azure Event Hub: used as Kafka server for storing the ingested events

The configuration will expose the services using the following domains:

* `platform.example.nebuly.com`: the frontend application
* `backend.example.nebuly.com`: the backend APIs
* `backend.example.nebuly.com/auth`: the authentication and authorization endpoints
* `backend.example.nebuly.com/event-ingestion`: the event ingestion APIs

The configuration assumes you have already create one or more secrets containing all the required credentials (these
secrets are referenced in the `existingSecret` fields of the configuration).

<details>
<summary> <b> Microsoft Azure values.yaml </b> </summary>

```yaml
imagePullSecrets:
  - name: my-image-pull-secret

secretsStore:
  kind: "azure_keyvault"
  azure:
    keyVaultUrl: "https://example.vault.azure.net"
    tenantId: "<your-tenant-id>"

    existingSecret:
      # -- Name of the secret. Can be templated.
      name: "my-secret"
      clientIdKey: "azure-client-id"
      clientSecretKey: "azure-client-secret"

backend:
  ingress:
    enabled: true
    className: nginx
    annotations:
        cert-manager.io/cluster-issuer: letsencrypt
    tls:
      - hosts:
          - backend.example.nebuly.com
        secretName: tls-secret-backend
    hosts:
      - host: backend.example.nebuly.com
        paths:
          - path: /api
            pathType: Prefix

eventIngestion:
  rootPath: "/event-ingestion"

  ingress:
    enabled: true
    className: nginx
    annotations:
        nginx.ingress.kubernetes.io/use-regex: "true"
        nginx.ingress.kubernetes.io/rewrite-target: $1
        cert-manager.io/cluster-issuer: letsencrypt
    tls:
      - hosts:
          - backend.example.nebuly.com
        secretName: tls-secret-backend
    hosts:
      - host: backend.example.nebuly.com
        paths:
          - path: /event-ingestion(/|$)(.*)
            pathType: Prefix


kafka:
  bootstrapServers: "<your-event-hub-name>.servicebus.windows.net:9093"

  existingSecret:
    name: my-secret
    saslPasswordKey: kafka-sasl-password
    saslUsernameKey: kafka-sasl-username

analyticDatabase:
  server: "<postgres-server-url>"
  name: analytics
  existingSecret:
    name:  my-secret
    userKey: postgres-user
    passwordKey: postgres-password

auth:
  postgresServer: "<postgres-server-url>"
  postgresDatabase: auth-service
  existingSecret:
    name: my-secret
    userKey: postgres-user
    passwordKey: postgres-password
    jwtSigningKey: jwt-key

  # Enable Microsoft SSO
  microsoft:
    enabled: true
    redirectUri: https://backend.example.nebuly.com/auth/oauth/microsoft/callback
    tenantId: "<your-tenant-id>"
    existingSecret:
      name: my-secret
      clientIdKey: microsoft-oauth-client-id
      clientSecretKey: microsoft-oauth-client-secret

  ingress:
    enabled: true
    className: nginx
    annotations:
        cert-manager.io/cluster-issuer: letsencrypt
    tls:
      - hosts:
          - backend.example.nebuly.com
        secretName: tls-secret-backend
    hosts:
      - host: backend.example.nebuly.com
        paths:
          - path: /auth
            pathType: Prefix


frontend:
  rootUrl: "https://platform.example.nebuly.com"
  backendApiUrl: "https://backend.example.nebuly.com"
  authApiUrl: "https://backend.example.nebuly.com/auth"
  ingress:
    annotations:
      cert-manager.io/cluster-issuer: letsencrypt
    enabled: true
    className: "nginx"
    tls:
      - hosts:
          - helmtest.internal.nebuly.com
        secretName: tls-secret-backend-helmtest
    hosts:
      - host: helmtest.internal.nebuly.com
        paths:
          - path: /
            pathType: Prefix

openAi:
  enabled: true
  insightsGeneratorDeployment: "gpt-4-turbo"
  textEmbeddingsDeployment: "text-embedding"
  frustrationDetectionDeployment: "gpt-4-0125-preview"
  chatCompletionDeployment: "gpt-3.5-turbo"
  endpoint: "https://<your-azure-openai-instance>.openai.azure.com"

  existingSecret:
    name: my-secret
    apiKey: azure-openai-api-key

azureml:
  enabled: true
  tenantId: "<your-tenant-id>"
  subscriptionId: "<your-subscription-id>"
  resourceGroup: "<your-resource-group-name>"
  workspace: "<your-aml-workspace-name>"
  batchEndpoint: "os-model-batch"

  existingSecret:
    name: my-secret
    clientIdKey: azure-client-id
    clientSecretKey: azure-client-secret
```
</details>

## Uninstalling the Chart

To uninstall/delete the `my-release` deployment:

```bash
helm uninstall my-release
```

The command removes all the Kubernetes components associated with the chart and deletes the release.


{{ template "chart.valuesSection" . }}

{{ template "chart.maintainersSection" . }}

{{ template "chart.sourcesSection" . }}
